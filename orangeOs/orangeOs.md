# orangeOs相关

## chp1 计算机启动
实现了一个简单的引导扇区代码

计算机启动过程，参考[boot](./boot.md)


## chp2 搭建环境
使用Bochs作为虚拟机模拟开发


## chp3 保护模式要点
- 实模式和保护模式
- 特权级
- 页式存储
- 中断和异常
- IO

详细参见[protected mode](./protected_mode.md)

## chp4 进入保护模式
实现了一个booter和loader
- booter即引导扇区代码，负责找到并加载loader，然后跳转到loader
- loader负责进入保护模式并初始化（堆栈、分页等）

### booter
* boot.bin写入磁盘第一扇区，并标记为可启动
* boot代码加载loader.bin，放入内存。跳转到入口

### loader
* 设置gdt
* 进入保护模式
* 初始化堆栈
* 启动分页
* 加载kernel.bin，跳到入口, kernel world now

## chp5 简单的内核
承接第四章，进入保护模式后，实现一个kernel

### kernel
* gdt按需调整
* 填充idt
    * 异常回调函数
    * 中断回调函数
* 初始化外部设备
    * 8259
* 初始化第一个进程
    * 初始化进程表
    * 设置tss、ldt
* 跳入ring3，进入第一个进程


## chp6 进程
### 进程表
每个进程要有一个进程表，来在进程切换时，保存和读取现场。

### 中断
* 在idt中注册中断回调函数
* 加载idt `lidt [idt_prt]`
* 发生对应中断，cpu会负责调用回调函数

关于中断重入: 

发生中断的时候，cpu会自动把中断关掉，然后调用中断回调。我们需要把中断打开（`sti`），否则其他中断（同类型中断，不同类型中断）不能执行（打字的时候不能动鼠标）。  

但当打开后，就会有重入的问题。我们可以做些处理满足我们的需求。比如我们判断是否是重入；我们也可以屏蔽掉同类型的中断，直到执行完成，这样就可以既不影响其他类型的中断，又能控制同类型的中断。

### 内核栈
orangeOs的内核栈是在kernel.asm中声明的，一共2k
```
[SECTION .bss]
StackSpace		resb	2 * 1024
```

但是注意，tss.sp0默认不是指向这里的。是指向进程的进程表的特定位置。  
这样，当发生中断／系统调用／进程切换时候，ring3->ring0，首先cpu会把当前进程（比如A）的现场压栈（eip,ss,esp,...），由于sp0的指向，刚好把这些信息存到A的进程表。然后内核可以把esp指向上面所说的2k空间，进行一些复杂的内核操作，进程切换等等。然后在ring0->ring3的时候，选择一个进程（B，或者还是A），把esp指向它的进程表的特定位置，执行`iretd`，cpu自动出栈（eip,ss,esp,...），就进入到ring3的B进程。

如上，tss.sp0指向某个进程（当前进程）的进程表的特定位置。每当ring3->ring0，现场被压栈入当前进程的进程表。每当ring0->ring3，现场从同一个位置（另一个进程的进程表的类似位置）恢复。这样，不同进程可以切换执行，中断的时候被cpu保存到进程表；恢复的时候被cpu从进程表恢复。而在ring0,cpu有单独的内核栈使用。在ring3，恢复各个进程自己的堆栈。

参考：
```
kernel.asm:329 设置当前栈顶（ring0）为申请好的2k区域，然后开始复杂的内核操作
        mov     esp, StackTop
kernel.asm:361 恢复ring0栈顶，指向要唤醒进程的进程表的特定位置，iretd会使cpu自动出栈，准备好此进程
	mov	dword [tss + TSS3_S_SP0], eax 
```

### 系统调用
orangeOs的系统调用是通过`int n`软中断实现的。  
在idt中注册一个处理函数（`sys_call`），对应中断号`n`(这里采用的是`0x90`), `sys_call`负责从一个初始化好的系统调用表里，根据调用时设置到`eax`的偏移，定位到对应的处理函数，并调用之。  

依赖：
* idt中注册一个系统调用入口函数(`sys_call`)
* 初始化一个系统调用表/数组，包含所有系统调用的处理函数

使用：
* 设定`eax`为要调用的系统调用在表内偏移（实际实现的时候，可以通过宏定义别名，方便记忆）
* 调用`int n`(启动`sys_call`,`sys_call`再根据`eax`调用对应处理函数)
* done

### 进程调度
利用时钟中断，来实现进程调用算法。  
每次中断发生，运行进程调度算法，根据不同进程的优先级，来决定下一个要运行的进程。

注：
- 时钟中断是从ring3->ring0，在ring0进行进程调度，准备好要运行的进程（填充ldt，寄存器），然后返回到ring3
- 每个进程都有自己的ldt。当进程切换时，需要重新加载ldt。ldt指定了当前进程的各个段（代码段、数据段）。ldt选择子保存在进程表


## chp7 IO
### 多终端
键盘和显示器是共享的。但我们可以准备多个虚拟tty。  
输入：  
根据当前tty的不同，把输入写入对应tty。

输出：  
把显存划分为多个部分，每个部分对应一个tty，这样就可以，在输出的时候通过指定不同的显存地址，来展示到不同的tty。

以上，我们通过虚拟tty，就可以拥有多个虚拟终端。

### 显存
我们可以通过CRT控制器来控制显示器的显示。比如可以设置屏幕显示对应的显存初始地址。这样，就可以通过设置不同地址，来显示不同内容。我们就可以通过将显存分割成几块，来分别对应到多个tty，单独使用。每次切换终端的时候，重新映射即可。（比如Linux的Alt+Fnx来切换终端）


## ch8 IPC
IPC（进程间通信），从技术实现上讲，就是普通的系统调用。更多地，它是一种规范或者方案。  
比如Minix，只有一个（sys_call)，三类（send,receive,both）系统调用，所有的其他调用都是通过这一个调用，加上IPC来完成的。

所有的系统调用都是服务化的Task，独立运行在ring1，所有的用户程序运行在ring3。用户程序想要什么服务，就通过唯一的系统调用发消息就行，指明要使用的服务。  
这样，用户进程，服务进程，内核进程，相互独立。内核只负责消息投递。大量的系统服务独立到ring1，所谓微内核架构。

举例，用户进程要设置当前时钟。
* user进程A发消息给时钟Task，我要设置当前时钟
* 发消息是系统调用，int软中断，陷入内核，os在消息体内标注来源是A，然后发消息(sys_sendrec)给时钟Task：
  * 如果时钟Task正在等待消息则直接复制过去，并解除他的阻塞。
  * 否则把A加入时钟Task的发送队列队尾。并阻塞A。
* （schedule进程调度）
* 时钟Task发现有消息，拿到消息，并设置当前时钟。
  * 时钟Task是在循环调用send_recv来接收消息。没有消息的时候就被堵塞；当有消息的时候就会被reschedule重新唤起。
如上，进程A和Task服务的沟通是通过消息（os代理投递）实现的。

另一个典型的场景，比如我要获取当前时钟。就需要用户进程先调用send发消息给时钟Task，再调用recv收消息。（实际是封装在一个函数内。）
* user进程A调用send_recv(BOTH,...)
* send_recv先调用sendrec(SEND)，再调用senrec(RECEIVE)，注意sendrec是系统调用（int软中断）
  * SEND操作会使os发消息(sys_sendrecv)给时钟Task，然后返回。
* （schedule）
* 时钟Task收到消息，获取时钟，并发消息（send_recv）给发送方（发送方在发送消息的时候，被os标记在消息体内）。
   * send\_recv调用int中断，使os调用sys\_sendrec，发送消息给A
* 回到RECEIVE操作，调用os收消息，收到Task发送的消息，返回给A
* done

注意，期间A调用了两次sendrec系统调用，一次发消息给时钟Task，一次收消息。  
而时钟Task也调用了两次，一次是收消息，一次是发消息。  
真实的流程是：A发消息，A阻塞，（schedule）；B收消息（同时A被解除阻塞），B发消息，B阻塞，（schedule）；A收消息（同时B被os解除阻塞，因为A收到消息了）。

所谓阻塞是说，在下一轮进程schedule的时候，不会被唤起（不会被分配到cpu时间片）。因为是同步IPC，必须接收方收到消息的同时，才能解除发送方的阻塞状态（代表发送成功）。如上面的，A发给B，则A阻塞，直到B收到。收消息也是一样，A收消息，A阻塞，直到有消息到达。

### 同步IPC、阻塞与schedule(进程切换)
因为是同步IPC
- 当A发消息而没有人在接收的时候，A会被阻塞，然后会触发schedule。
- 当A收消息而没有已到达的消息的时候，A会被阻塞，然后会触发schedule。

需要注意的是，每次阻塞，都会触发reschedule，因为当前进程已经无法继续了。所以在处理完消息，且发送／接收的用户程序被阻塞的时候，都会触发reschedule，马上启动别的程序，而不是等待下一个时钟中断。

综合，schedule发生在：
- 进程被阻塞的时候（自动schedule）
- 时钟中断（定时schedule）



## ch9 文件系统
### 硬盘Task
硬盘Task（`task_hd`)的实现及使用流程：
- user process A 发消息给Hd Task
- Hd Task 收到消息
  - 发送指令给硬盘端口，请求硬盘数据(`hd_identify`)
  - 利用send_recv同步IPC，指定要接收中断消息。
    - 进程被block
    - schedule
    - 中断发生，执行中断回调（`hd_handler`）。回调设置消息，并解除进程block（ring 0）
    - schedule
    - 进程被唤起，继续。
  - 收到消息后，发消息给A
- A 收到消息
- done

注意：中间省略了A发消息后被block，收到消息被唤起等ring0的细节。实际上，所有的收发消息都会经历被block，陷入ring0，schedule，被重新唤起等流程，这个在第ch8详细说明过，故而不再赘述。

### 知识点
- 物理地址`0x475`处记录了硬盘数量，BIOS设置等。//todo bios的其他设置还有哪些哪

### 文件系统
文件系统需要提供的：
- 格式化硬盘分区方法（安装自己）
- 提供open,write,read,close方法（对外提供使用方法）
简单来说，文件系统就是对硬盘存储空间的管理，一层抽象，提供接口让用户更方便的使用。（而不是让用户直接操作硬盘，效率太低）

（结构是质。结构带来质的变化）

在*nix中，一切设备都是以文件的形式存在，只是底层实现不一样。在这种体系下，文件是一种抽象和封装，其他一切都以文件的形式对上层提供服务。

#### 读写tty
tty也被抽象为普通文件。对tty的读写，类似读写普通文件，都通过fs的统一接口。
- 写
  - P发消息给fs，要写入
  - fs判断是要写入tty，发消息给task_tty
  - task_tty写入显存（此时屏幕上可以看到了），发回消息给fs
  - fs发回消息给P
  - done

- 读
  - P发消息给fs，要读取
  - fs判断是要读取tty，发消息给task_tty
  - task_tty发回消息给fs，要求fs阻塞P
  - fs阻塞P（不发消息给P）
  - ...(task_tty通过时钟中断的不断唤起（当有键盘中断发生时，会标记；时钟中断通过标记来判断是否有输入发生，依此判断是否唤起task\_tty），不断接收键盘消息，并显示出来)
  - task\_tty遇到回车，发消息给fs，要求唤醒P
  - fs发消息给P
  - done


## ch10 内存管理
### fork
orangeOs的fork实现：
- A进程调用fork函数
- fork发消息给MM，并等待返回，A被阻塞（IPC消息系统）
- reschedule
- MM收到消息，新建进程C，做如下初始化：
  - 进程表，复制自A
  - 分配内存，拷贝自A
  - ldt等新条目
- MM 拿到C的pid=x（一般地，是系统进程表的偏移）
  - 发消息给C，消息内包含pid=0
  - 发消息给A，消息内包含pid=x
- reschedule
- A被唤起，消息体内包含pid=x，fork函数返回x，A知道自己是父进程，继续执行
- C被唤起，消息体内包含pid=0，fork函数返回0，B知道自己是子进程，继续执行。

注意，A调用`sendrecv`（内部调用int中断）的时候，状态被存储；然后被IPC阻塞，因为A要的消息还没有。

之后操作系统重新schedule要运行的程序。当MM运行的时候，MM按照当时A的状态复制一份成C。然后发消息给C，
发消息给A。

当下次reschedule的时候，A，C各自被唤起，并从被阻塞的地方返回。  不一样的是，A、C拿到的消息不一样，一个包含`pid=0`，一个包含`pid=x`，从此开始新的一段旅程。

需要注意的是，由于进程切换，真实的场景可能有几个，比如
- A调用fork
  - fork调用IPC SEND，被阻塞
- reshedule
- MM收到消息，并解除fork阻塞。MM初始化新进程C，并发消息给A、C
- reschedule
- （A）fork调用IPC RECEIVE，收到消息，PID=x
- reschedule
- （C）fork调用IPC RECEIVE，收到消息，PID=0

或者：
- A调用fork
  - fork调用IPC SEND，由于当前MM正在等待消息，所以马上返回。
  - fork调用IPC RECEIVE，A被阻塞
- reshedule
- MM收到消息，MM初始化新进程C，并发消息给A、C
- reschedule
- （A）fork调用IPC RECEIVE，收到消息，PID=x
- reschedule
- （C）fork调用IPC RECEIVE，收到消息，PID=0

如上，其实就是由于时钟中断触发的进程切换的存在，执行顺序是不一定的。但是，通过同步IPC，配合阻塞，就可以保证逻辑的有序性，从而最终保证逻辑的正确性。


### shell
shell其实就是个普通进程，接受输入，然后按照规则解释。规则就是，
- 判断输入的第一个参数是不是个自身支持的命令，是就执行。
- 判断输入的第一个参数是不是个文件，并且可执行，是则fork。在父进程内调用`wait`等待子进程完成并拿到返回值。子进程内，调用exec。exec作如下处理：
  - 读取文件，根据可执行文件的内存布局初始化（比如elf文件，读取头部，把相应的段放入内存相应的地方）
  - 初始化进程表等，比如设置进程表内`eip`为代码入口地址
  - 等下次reschedule就会执行从设置的入口地址执行。
- 其他，提示错误。


### 注意
本章编译时，需要`elf.h`头文件（用到了一些定义）。但是在Mac OSX上，没有，
- 在Linux下找到编辑下，去除不必要的引用，放到`/usr/local/include `下即可。
- 或者直接用[这个](https://gist.githubusercontent.com/lunaczp/1a2ee039ec36361a732e079037b08874/raw/2ee259afd8407d635a9149fcc371fccf08b0c05b/elf.h)
- 或者手动把需要的定义加上也可以。


## ch11 硬盘引导
### 硬盘boot
orangeOs之前一直是通过软盘启动。
- 写入软盘第一扇区boot代码
- boot找到loader，加载loader，执行
- loader初始化（保护模式...），找到kernel，并加载

现在通过硬盘启动。
- 写入硬盘第一扇区boot代码
- boot找到loader，加载loader，执行
- loader初始化（保护模式...），找到kernel，并加载

需要注意的是，软盘用的是fat文件系统，硬盘用的是orangeOs的文件系统，所以两者在文件定位的时候不一样。

### 多系统启动
- 将orangeOs的boot代码写入到orangeOs分区的引导扇区（参考之前的磁盘分区），而不是整个磁盘的引导扇区。
- 安装grub到硬盘
- 启动的时候，通过grub指定从orangeOs分区启动
- done