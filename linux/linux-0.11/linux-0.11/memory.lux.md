# Memory
内存管理


## Intro
物理内存的分配都是以页为单位的。系统维护一个全局的`mem_map[PAGING_PAGES]`数组，每个元素对应一个物理页(4K)。


## [Paging](paging.lux.md)


## Memory Layout Varity
- bios把bootsect(512byte)加载到`0x7c00`
- bootsect
    - 把自己从`0x7c00`移动到`0x90000`(9*2^16=576k处)
    - 再把setup读取到内存地址`0x90200`
    - 再把system读取到内存地址`0x10000`(2^16byte=64k处)
    - 跳转到setup `0x90200`
- setup
    - 读取硬件信息，并存储到 `0x90000-0x901FF`
    - 移动内核(system)，对齐到`0x00000`
    - 初始化gdt：定义了8Mb的Code段，定义了8Mb的Data段
    - 标记cr0的PE=1，切换到保护模式
    - 跳转到CS:0，即代码段内偏移0处，也即决定内存地址`0x00000`处，也就是system被加载的位置，进入head.s部分代码（head.s是system的第一个区块）
- head.s
    - 初始化GDT
        - 共256个gdt条目，并初始化内核使用的0x08 (CS,16MB),0x10 (DS,16MB)两个段
    - 初始化分页(页表位于0x0，覆盖占用了原来head.s的位置)
        - 页目录表：一个表项4byte，共1024个表项，占用4kb，从(0x0000-0x1000)
        - 页表：
            - 一个表项4byte，共1024个表项，占用4kb，每个表项对应一个4kb物理页
            - 一个页表映射了4mb物理内存
            - 这里只定义了4个页表(0x1000-0x2000,...0x4000-0x5000)，刚好映射16mb的物理内存，逻辑地址与物理地址一一对应，给内核使用。所以在启用分页后，内核模式（当前cs，ds对应的是内核段，cs:0x08,ds:0x0x10）下，内核相当于依然可以直接访问物理内存。
            - 实际的线性地址有4gb，共有1个页目录表，包含1024个表项，对应1024个页表。这个只定义了4个页表，剩下的页表由程序用到的时候填充。
    - 启动分页
    - 手动构造调用栈，返回，进入main函数
- kernel main
    - 初始化内存
        - 计算总内存空间
        - 切一段出来作为缓存（buffer）
            - 根据总内存的大小，分配缓存区。超过12mb，用4mb；超过6，用2；否则1
        - 剩余内存空间为用户可用，初始化
            - 填充全局`mem_map[PAGING_PAGES]`，每页4kb，共`PAGING_PAGES`页，将可用页标记为可用。
            - 之后所有的物理页请求都要通过`mem_map`来统一管理
        - 注意，kernel本身是用c写的，编译后生成的`.text，.data, .bss`是固定的，即代码内的变量的位置在加载到物理内存后是基本确定的，在指定范围内(如临时变量会被分配到`.bss`内)，且都在`0-640kb`(内核大小)范围内。这部分代码和变量不受`mem_map`管理，(实际上，`mem_map`映射的物理内存下界是1mb, see [`mm/memory.c:LOW_MEM`](mm/memory.c)）
            - 即，内核代码本身运行产生的数据都在内核自身范围内(`0-640kb`)，而内核可寻址/管理的是整个物理内存，特别地，给上层提供的内存通过`mem_map`管理。
        - 当前物理内存状态：
            ```
            0              640k                 1024k(1m)                  16m
            |------------|----------------------|-------------------...----|
            |kernel      |Video Card,BIOS ROM   |avaiable memory           |
            ```
    - 各种初始化后，进入用户态（task[0])
    - 关于进程
        - Linux维护一个全局的`task[NR_TASKS]`数组，共64项，也即系统最多可以有64个进程。
        - 每个数组元素是一个`task_union`结构体，大小刚好是一个页（4kb）
         ```
         union task_union {
         	struct task_struct task;
         	char stack[PAGE_SIZE];//lux 利用union结构，构造了一个PAGE_SIZE(4k)大小的空间，上面作为task存储，下面作为堆栈。在task_union的底部作为栈顶，提供一个向下的堆栈，供init_task在内核态使用,see sched.h INIT_TASK tss.esp0
         };
         ```
        - 系统静态定义了`task[0]`为`INIT_TASK`，其实这就是当前进程（内核进程自己）。当fork出新进程，并进行schedule调度后，如果内核进程被切换，就会保存到`task[0]`定义的tss，并在之后的schedule策略中被重复调度。
    - fork子进程
        - 首先，要在`task`中找到一个空闲表项，这里就是`task[1]`
        - 获取一个task_union结构体，这时候就要新分配一个物理页面，`get_free_page`从`mem_map`倒序返回第一个空闲页，也就是`mem_map[PAGING_PAGES-1] 即，mem_map[3840-1]`;
        - 各种初始化
        - 拷贝内存数据到子进程。
            - 首先计算新的cs、ds。注意，Linux线性地址的分配方式是，在4gb的线性地址空间上，按序为每个进程分配64mb空间，那么第nr个进程的空间为（nr*64 至 nr+1*64）,对于第一个进程，则是64mb~128mb。cs，ds都从64mb开始。
            - 这里不会真的拷贝物理内存，而只是拷贝页表，从而使子进程内的代码数据直接映射到和父进程一样的物理区域，而延迟到当有数据变更的时候当由缺页程序负责申请新页（CopyOnWrite），提高了内存利用率。
                - 由于我们知道在系统初始化的时候，只为kernel填充了4个页表，映射16mb物理内存。其他页表都还没有，所以这里我们需要申请新页来作为页表
                - 正常情况，一个进程占用64mb线性地址，共需要16个页目录表项，对应16个页表，一个页表4k，需要分配16个新页。
                - 但是task[0]定义的dataLimit只有640k，所以在fork出task[1]的时候，`copy_page_tables`对应的dataLimit=640k，只需要一个页目录表项，对应一个页表。所以这里我们只调用`get_free_page`一次，拿到`mem_map[PAGING_PAGES-1]，即mem_map[3840-2]`。
        - 更新ldt和tss到gdt。标记进程可运行。返回
    - 此时的线性地址空间分布是：
        ```
        0      640kb      64mb                     128mb                      4gb
        |---------|---------|----------------------|-------------------...----|
        |task[0]  |         |task[1]               |                          |
        ```
    - 此时的物理地址空间分布是：
        ```
        0                                        20kb          640kb             1mb              15mb          15mb+1022kb               15mb+1023kb                    16mb
        |----------------------------------------|-------------|-----------------|-----------...--|--------...---|--------------------------------|-----------------------|
        |partial page table(1个页目录表，4个页表)   |kernel       |VIDEO,BIOS ROM   |                               |第5个page table，映射64mb-128mb   |task[1]的物理地址        |
        ```
    - 父进程(task[0])
        - loop (pause -> schedule)
    - 子进程（task[1])，传说中的INIT进程，pid=1的进程
        - 初始化驱动，（加载磁盘，加载根文件系统）
        - 新子进程task[2]，运行开机脚本`/etc/rc`，等待开机脚本运行完毕
        - Loop
            - 子进程
                - exec:/bin/sh，shell show time
            - wait child


注意，当执行`exec`系统调用的时候，会调用`change_ldt`，设置代码段和数据段的界限。Linux本身是不进行C&D分割的，也就是说code和data是在同一段连续的逻辑地址空间。而这里利用`change_ldt`，根据可执行文件的text段大小来重设code段界限，从而保证data段的数据不会被执行（恶意情况）。

`change_ldt`:
- 设置code limit为text_size
- 设置data limit为64mb

ps. 从task[0]fork出来的所有进程，其data limit都是640kb。只有当通过`exec`启动的进程，才会真正变成64mb（通过`change_ldt`）。