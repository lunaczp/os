# Paging
Paging，类似Segment，是Intel提供的可选的内存管理方式。不同的是Segment是必选的，Paging是可选的。

Paging可以提供更细粒度的内存管理。另外，基于Paging可以实现按需加载，从而允许运行一个远大于实际物理内存的程序。

## 基本概念

### 虚拟地址/线性地址/物理地址
- 虚拟地址（逻辑地址），程序使用的地址，Segment机制可寻址的地址
    - 虚拟地址由Segment提供，对于8086，由`16bit的segment selector：32bit offset`组成。每段4GB。假设gdt内有1024个不重叠的段，那么虚拟地址空间就是4TB。
- 线性地址，cpu可寻址的线性空间
    - 取决于cpu的地址总线，对于32地址总线，可寻址端线性空间是2^32=4GB。
- 物理地址，内存真实地址
    - 取决于真实内存大小。对于Linux0.11时候，Linus的电脑内存是16MB。

### 地址转换
- 最初的cpu寻址，直接寻址的就是物理内存地址。
- 引入Segment之后，程序使用的是逻辑地址，经过Segment转换，得到物理内存地址。
- 引入Paging之后，程序使用的是逻辑地址，经过Segment转换，得到线性地址；经过Paging转换得到物理内存地址。

## 实现

### Paing的实现
要启用Paging，需要提供给cpu一个二级页表。然后通过CR3指定页表的入口。这样，cpu就可以利用页表来进行地址转换了。

页表具体分为页目录表（一级表）和页表（二级表）。
- 页目录表存储的是二级页表的地址
- 页表存储的是物理页的地址

### 地址转换
对于一个32位的地址
- 取[22-31]，作为页目录表的偏移，获取到保存的页表基址。
- 取[12-21]，作为页表内偏移，结合页表基址，得到页表项地址，读取保存的物理页基址
- 取[0-11]，作为物理页内偏移，结合物理页基址，得到物理地址。
- done

注意，页表内的地址都是物理地址。


## Linux 0.11的分页
Paging是对内存的管理。进程是运行在内存中的，因而对进程空间的管理，也是基于Paging的。

Linux0.11下，8086可寻址的线性空间是4GB。Linux给每个进程划分64MB的线性空间，对于task[n]，
- 其线性空间基址是start = (n-1)*64MB。
- 其codeBase，dataBase都是start
- 段界限
    - 内核的 代码段和数据段都是16MB
    - task0 是640KB
    - task1 是640KB
    - task[n]，经过`exec`启动的进程，codeLimit等于.text段大小,dataLimit=64KB，参考[memory](memory.lux.md)，[mm/memory.c](mm/memory.c)

所有进程使用同一个页表结构。也就是所有进程的CR3都是一致的（fork直接继承，且没有修改，所以在之后进程切换的时候，CR3虽然也会重新加载，但值都一样）。在系统初始化的时候，定义了4个页目录表，每个对应1024个页表项，则每个页目录表项对应4MB空间，共16MB，如此实现了16MB内存的虚拟地址、线性地址、物理地址的直接映射，供内核进程使用。


### fork
- 当fork的时候，会复制父进程的页表数据给子进程一份。子进程有自己的页目录表项和页表项，但是指向的物理地址与与父进程相同，且物理内存被设置为不可写。
- 当随后发生写入的时候，系统再分配新的物理页，拷贝物理数据，更新页表。从而实现延迟分配物理内存。

### 进程内的地址访问
从上面我们知道，当进程fork的时候，我们是复制了页表数据，也就是两个进程通过不同的页表，映射到了同一个物理地址。那这个时候进程内的地址是如何访问的呢。比如，一个变量‘A’，在两个进程内，是如何映射到它的物理地址的呢。

- 进程内的地址，是相对地址，比如A的地址是offsetA。
- 寻址的时候，结合cs/ds，计算出线性地址linearA = ds:offsetA
- linearA通过上面我们设置的页表结构，最终定位到页表内保存的物理地址，phyA
- 读取phyA，获取到A的值。

如上
- 对于一个程序来讲，offsetA是一定的（在一台机器上/编译环境）
- 对于不同进程来讲，offsetA是相同的，linearA是不同的，因为其cs/ds是不一样的。从而映射到不同的线性地址空间。
- 对于不同进程来讲，phyA是不同的。注意，刚fork完成，没有写入的时候，是共享的，因而相同。当随后有写入的时候，会单独分配，从而最终是不同的。


对Linux0.11，每个进程有64MB寻址空间。task[n]对应的cs/ds是n*64MB。如此整个4GB可寻址空间被一个个task依次占用。

实际上，这里面的地址转换是怎么发生的呢。
- 通过cs/ds的设置，把每个进程，分割到了64mb间隔的内存区域
- 通过页表地址转换，刚好把某个进程的线性地址，映射到了它的页表上。

__具体参考__[memory.c:140 copy_page_tables](./mm/memory.c)

比如，
- 进程1，占用内存空间64MB-127MB，cs/ds = 0x0400,0000 (64MB)，进程内一个变量地址A=0x1。
- 当CPU对这个逻辑地址寻址时候，结合ds，生成线性地址：0x0200,0001。
- 线性地址->物理地址
    - 页目录表条目 0x0400,0001 >> 20 = 0x040,一个表项4byte，因而0x40是第0x10（16 in decimal）项。
    - 找到第0x040处存放的二级页表地址，比如pg_table.
    - 计算表内偏移，取0x0400,0001的12-21bit，得到0x0，0x0/4k = 0，也就是说，0x1在pg_table[0]。
    - 读取pg_data[0]对应的物理页数据，设为data[4096]。由于0x0400,0001的页内偏移是低10bit，即0x1，那么我们要读取的数据就在data[1]，结合A的数据类型（int、long、char），我们可以决定具体要读取的字节数。
- 如上，我们获取到了一个进程内，某个变量对应的真实物理内存地址。

总结
- 程序内的地址/变量寻址是相对地址。结合cs/ds:offset，得到线性地址。
- 通过每个进程cs/ds的不同，从而实现了进程隔离。同一个程序可以被加载到不同的内存地址来独立运行，而不需要改变代码。
- 通过分页，实现了逻辑地址和物理地址的映射，允许进程共享物理内存和按需加载。


## Demand Paging
Demand Paging是一种按需加载技术，其优点有：
- 实现在较小的内存上运行本身大于实际内存的大程序
- 提高内存利用率。

实现和使用场景：

### Case 1:fork进程
当fork进程的时候，理论上是要把父进程的内存完全复制一份给子进程即可。在使用demand pading的情况下，当fork的时候，只会拷贝父进程的页表，从而使子进程和父进程指向同一块物理内存。  
- 此时页表内相应内存页会标记为写保护。
- 之后父子进程都可以继续运行。
- 当有一方尝试写入某页的时候，cpu触发写保护异常，中断程序介入，调用处理进程`do_wp_page`
    - 分配新的页面，并赋值给页表项。原有物理页引用--。
- 如此，实现了物理页的延迟/按需分配。其实对于代码段，是不变的，当多个进程使用同一个可执行文件（或者共享库等等），没有必要为每个进程分配重复的物理内存。


### Case 2:exec执行可执行文件
当使用`exec`来执行文件的时候，
- 填充进程体
- 清空当前进程的页表
- 设置eip为新的二进制文件的入口`entry`

如此，当继续执行的时候，由于eip指向二进制文件入口`entry`，
- cpu尝试读取`entry`指向的物理内存，经过分段、分页转换后，在页表发现该页不存在，产生缺页中断，调用`do_no_page`
    - 检测是属于需要加载二进制文件数据的情况下:
        - 尝试共享物理页，成功则返回，否则继续。
        - 分配新页，并读取二进制文件，填充到物理页
        - 新页赋值到指定的逻辑地址
        - 返回